// код, который превращает римское число (от 1 до 15 стмволов) в арабское
// на всякий случай

var arrayRomeString = {i:"I", v:"V", x:"X", l:"L", c:"C", d:"D", m:"M"};
var arrayArab = {i:1, v:5, x:10, l:50, c:100, d:500, m:1000};
var maybe = {"I":1, "V":5, "X":10, "L":50, "C":100, "D":500, "M":1000};


//  наша строка
var s = "VCMMD";
//  это для перебора строки
var k = 0;
// это для итогового числа
var end = [];


// определяем, является ли строка римским числом и соотв ли они условиям

for (var j=0; j<=s.length; j++) {
if (s[j] == "I" || s[j] =="V" || s[j] =="X" ||
s[j] =="L" || s[j] =="C" || s[j] =="D" || s[j] =="M" )
{k++;} else {}  };

if (s.length > 15 || s.length == 0 || k != s.length) {
console.log ("некорректное число"); }
else {  console.log("корректное число");
}
console.log("длина строки = ", k, "символ(а)");

// теперь переводим римское число в арабское
// сначала определим какие римские цифры есть в числе и сколько их
// Эта функция должна сперва определить есть ли указываемый элемент
// в строке, а потом посчитать сколько таких эл-тов
// с RegExp были сложности, о таких штука почему-то нигде не рассказывают
// пришлось гуглить про флаги и как их подружить с переменными, но всё равно надо это подтянуть
// после того, как я сделала функцию whereRomе, функция whichRome стала неактуальна, но она рабочая
        //
        // function whichRome (r) {if (s.includes(r)) {
        //   var q = s.match(new RegExp(r, "g"));
        //   var t = Number(q.length);
        //   console.log(r, "повторяется", t, "раз(а)");
        //   return t;
        // } else {console.log("нет такого")};
        // };

// теперь определим индексы, чтобы понять, есть ли у нас вычитания, типо числа 4(IV)
// я этот код нашла в инете, потребовалась помощь чтобы понять
// хотела попробовать по-своему через for, но вышла какая-то ересь
// в целом оно находит индекс по первому совпадению, добавляет его в indexRome, потом начинает искать скова со следующего
// и так пока не закончатся совпадения. Потом возвращает массив индексов

// это чат GPT подсказал, но я хочу попробовать по-своему сама
// var result = 0;
// for (var i = 0; i < s.length; i++) {
//   var currentNumeral = maybe[s[i]];
//   var nextNumeral = maybe[s[i + 1]];
//   if (currentNumeral >= nextNumeral) {
//     result += currentNumeral;
//   } else {
//     result -= currentNumeral;
//   }
// }
// console.log("Arabic numeral:", result);

function whereRome (h) {

  var indexRome = [];
  var y = s.indexOf(h);
  while (y !== -1) {
    indexRome.push(y);
    y = s.indexOf(h, y+1);

  }
  var line = indexRome.length;



    console.log(h, "повторяется", indexRome.length, "раз(а)\n", "индекс(ы)", h, "=", indexRome)

// эта часть переводит римское в арабское, но без учёта сумм и вычитаний при составных римских числах
// щас надо сделать, чтоб считал для составных и потом собирал нормальное арабское число
// думаю сперва прописать, чтоб разность для таких чисел как 4 находил, а потом уже прописать чтоб суммировал получившиеся кусочки в арабское число
// возвращает нам массив букв, перведённых в арабсике числа

  var n = maybe[h] * indexRome.length;
  console.log(n);

    console.log(indexRome[0]);

end.push(n);
console.log(end);

return end;
}

// в этой части были проблемы, потому что ни break, ни continue
// не срабатывали как надо. я обратилась к gpt и он дал мне ту часть кода, что выше всей этой функции
// заменила своё на (maybe[s[w]] >= maybe[s[w+1]] и ([s[w]] >= [s[w+1]] и оно заработало
// раньше я, кажется, сравнивала просто w и w+1, потому и не работало.
//

// ещё чучуть задолбалась. просто со сравнением оно работало для повторяшек, но прерывалось на этом и числа после повторяшек не считывало
// каким-то гениальным озарением я допёрла, что можно для повторяшек просто переходить на след шаг, а не прерывать через break или continue


for (var w = 0; w<s.length; w++) {
  whereRome(s[w]);
  if (s[w] === s[w+1]) {
    w++;  }

};

// теперь соберём массив арабсткх числел в одно числом

var itog = 0;

//  тут тоже помогла та штука из gpt. я пыталась прописать и по-своему и через её способ. оба работают.
// но без gpt у меня бы не вышло, наверное


for (var o = 1; o < end.length; o++) {

  if (end[o] < end[o-1]) {
    itog += end[o] + end[o-1];
  } else {
    itog -= end[o-1];
  }


// if (end[o] > end[o-1]) {
//   itog += end[o];
// } else {
//   itog -= end[o];
// }
console.log(itog);
}
